<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>NCC DarkCPU: Memory Manager</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="large.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">NCC DarkCPU
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_memory.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Memory Manager </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>Memory Manager  MemoryManager</h1>
<h2>Relavent Code Modules:</h2>
<p><a class="el" href="memory-10c_8c.html#MemoryManager">MemoryManager</a></p>
<h2>A Brief on The Concept of Memory Management DarkCPU</h2>
<p>The memory manager (<a class="el" href="memory-10c_8c.html#MemoryManager">MemoryManager</a>) in DarkCPU is responsible for allocating, freeing and protecting memory inside of the system. All memory inside of DarkCPU divided into sections referred to as memory chunks, which are a given words division of memory. The particular size of a memory chunk is defined by <a class="el" href="memory-10c_8c.html#ab27273ecae70845cfcdd5da3b6aabba0">MEMORY_CHUNK_SIZE</a> The state of each memory section is defined inside of the <a class="el" href="memory-10c_8c.html#a64af9302970399e6ada5588b6856216f">memory_allocationBitmap</a>. Where the first bit in the bitmap defines the state of the first memory chunk, and the next bit defines the state of the following memory chunk, etc...</p>
<p>When the user requests to allocate a region memory of a given size, the memory manager will round up the size such that it aligns to the size of a memory chunck. I.e, allocating 1 word via the memory manager will actually result in a memory allocation of <a class="el" href="memory-10c_8c.html#ab27273ecae70845cfcdd5da3b6aabba0">MEMORY_CHUNK_SIZE</a> words. This is done to minimize the size of the allocation table and maximize the number of possible memory divisions.</p>
<h2>Reserving Memory</h2>
<p><a class="anchor" id="ReservingMemory"></a>The DarkCPU Memory Manager allows the user to reserve a region of memory. A reserved memory region is ignored by the memory manager and treated as if it hadn't even existed in the first place. The BootCode uses this routine of the memory manager to reserve the region of memory the kernel image has been loaded into.</p>
<dl class="section attention"><dt>Attention</dt><dd>It is important to note that reserving memory does not guarantee that the memory region being reserved has not already been allocated or reserved. I.e, it is important to be aware of what lies inside of the memory region you are reserving.</dd></dl>
<h2>Memory Swapping </h2>
<dl class="section note"><dt>Note</dt><dd>This has not yet been implemented</dd></dl>
<p>Memory Swapping is an effective way for the DCPU kernel to maximize the use of its memory without an MMU. It allows on-demand defragmentation of memory, allowing more contiguous regions of memory to exist and allowing the system to allocate more memory than is physically accessible. The swapping system works by allowing the user to allocate swapped memory. Swapped memory is a special kind of memory in the DarkCPU kernel as will be described below. Swapped memory can be placed in either a locked or unlocked state.</p>
<p>When the user initially allocates a swapped memory region, it is placed in an unlocked state, which means it has no valid base address and that the memory region does not exist in memory.</p>
<p>After placing the swapped memory region into a locked state via one of the swapped memory locking routines, it will be loaded at a given base address in memory. The specific address it is loaded at will be provided by the locking routine.</p>
<p>The user may then continue to mutate or read the data region, as if it were a normal region of allocated memory. Once the application has finished working with the memory, it can be placed into an 'unlocked' state.</p>
<p>When a swapped memory region is unlocked, it is not expected to be read from or written to and thus the kernel assumes that, if need be, the memory region can be relocated or swapped out on to another storage device. When the memory region is locked again, the kernel will assure it is loaded back into memory and will provide the caller of the locking routine the details regarding which base address it is loaded at.</p>
<dl class="section note"><dt>Note</dt><dd>Wherever possible, swapped memory should be used over the primitive memory allocation methods for reasons described above.</dd>
<dd>
Just because a swapped memory region is in an unlocked state, does not mean that the kernel will swap it out of memory. In all likelihood, if the system is not pressed for memory and the memory is not too poorly fragmented, the data region will be left untouched to optimize the locking procedure. However this is not guaranteed and the user should not assume that is hasn't been swapped out. </dd></dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Jan 14 2013 00:25:40 for NCC DarkCPU by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.2 </li>
  </ul>
</div>
</body>
</html>
